"""
Student-triggered on-demand AI content generation endpoints
Students can generate Summary, Q&A, and Podcast for PUBLIC books only
First student to generate creates it for everyone
"""
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.config.database import get_db
from app.models.books import Books
from app.models.static_content import StaticContent
from app.services.gemini_ai import generate_summary, generate_qa_pairs, generate_podcast_script
from app.services.audio_generation import generate_podcast_audio

router = APIRouter(prefix="/student/generate", tags=["student-generation"])


@router.post("/books/{book_id}/summary")
def generate_summary_student(book_id: int, db: Session = Depends(get_db)):
    """
    Student-triggered on-demand summary generation.
    Only works for PUBLIC books. First student to request generates for all.
    """
    book = db.query(Books).filter(Books.book_id == book_id).first()
    if not book:
        raise HTTPException(status_code=404, detail="Book not found")
    
    if book.is_public == 0:
        raise HTTPException(status_code=403, detail="This book is confidential. AI content generation is not allowed for students.")
    
    # Check if already exists
    content = db.query(StaticContent).filter(StaticContent.book_id == book_id).first()
    if content and content.summary_text:
        return {"message": "Summary already exists", "summary": content.summary_text, "generated_now": False}
    
    try:
        print(f"Student generating summary for book {book_id}...")
        summary = generate_summary(book.pdf_url)
        
        if content:
            content.summary_text = summary
        else:
            content = StaticContent(book_id=book_id, summary_text=summary)
            db.add(content)
        
        db.commit()
        print(f"✓ Summary generated by student")
        return {"message": "Summary generated successfully!", "summary": summary, "generated_now": True}
    except Exception as e:
        db.rollback()
        error_msg = str(e)
        if "429" in error_msg or "RESOURCE_EXHAUSTED" in error_msg:
            raise HTTPException(status_code=429, detail="API quota exhausted. Please try again later (wait 24 hours or contact admin for more keys).")
        raise HTTPException(status_code=500, detail=f"Generation failed: {error_msg}")


@router.post("/books/{book_id}/qa")
def generate_qa_student(book_id: int, db: Session = Depends(get_db)):
    """
    Student-triggered on-demand Q&A generation.
    Only works for PUBLIC books. First student to request generates for all.
    """
    book = db.query(Books).filter(Books.book_id == book_id).first()
    if not book:
        raise HTTPException(status_code=404, detail="Book not found")
    
    if book.is_public == 0:
        raise HTTPException(status_code=403, detail="This book is confidential. AI content generation is not allowed for students.")
    
    content = db.query(StaticContent).filter(StaticContent.book_id == book_id).first()
    if content and content.qa_json:
        return {"message": "Q&A already exists", "qa": content.qa_json, "generated_now": False}
    
    try:
        print(f"Student generating Q&A for book {book_id}...")
        qa_json = generate_qa_pairs(book.pdf_url, 10)
        
        if content:
            content.qa_json = qa_json
        else:
            content = StaticContent(book_id=book_id, qa_json=qa_json)
            db.add(content)
        
        db.commit()
        print(f"✓ Q&A generated by student")
        return {"message": "Q&A generated successfully!", "qa": qa_json, "generated_now": True}
    except Exception as e:
        db.rollback()
        error_msg = str(e)
        if "429" in error_msg or "RESOURCE_EXHAUSTED" in error_msg:
            raise HTTPException(status_code=429, detail="API quota exhausted. Please try again later (wait 24 hours or contact admin for more keys).")
        raise HTTPException(status_code=500, detail=f"Generation failed: {error_msg}")


@router.post("/books/{book_id}/podcast")
def generate_podcast_student(book_id: int, db: Session = Depends(get_db)):
    """
    Student-triggered on-demand podcast generation.
    Only works for PUBLIC books. First student to request generates for all.
    """
    book = db.query(Books).filter(Books.book_id == book_id).first()
    if not book:
        raise HTTPException(status_code=404, detail="Book not found")
    
    if book.is_public == 0:
        raise HTTPException(status_code=403, detail="This book is confidential. AI content generation is not allowed for students.")
    
    content = db.query(StaticContent).filter(StaticContent.book_id == book_id).first()
    if content and content.podcast_script and content.audio_url:
        return {"message": "Podcast already exists", "script": content.podcast_script, "audio_url": content.audio_url, "generated_now": False}
    
    try:
        print(f"Student generating podcast for book {book_id}...")
        podcast_script = generate_podcast_script(book.pdf_url)
        audio_url = generate_podcast_audio(podcast_script, book_id)
        
        if content:
            content.podcast_script = podcast_script
            content.audio_url = audio_url
        else:
            content = StaticContent(book_id=book_id, podcast_script=podcast_script, audio_url=audio_url)
            db.add(content)
        
        db.commit()
        print(f"✓ Podcast generated by student")
        return {"message": "Podcast generated successfully!", "script": podcast_script, "audio_url": audio_url, "generated_now": True}
    except Exception as e:
        db.rollback()
        error_msg = str(e)
        if "429" in error_msg or "RESOURCE_EXHAUSTED" in error_msg:
            raise HTTPException(status_code=429, detail="API quota exhausted. Please try again later (wait 24 hours or contact admin for more keys).")
        raise HTTPException(status_code=500, detail=f"Generation failed: {error_msg}")
